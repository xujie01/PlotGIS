define(["dojo/_base/declare","dojo/_base/lang","dojo/_base/connect","dojo/_base/array","dojo/has","dijit/Menu",    "dijit/MenuItem","esri/kernel","./_VertexMoverEx","esri/geometry/Point","esri/geometry/jsonUtils",    "dojo/i18n!esri/nls/jsapi"],     function (declare, lang, connect, array, has, Menu, MenuItem, kernel, VertexMoverEx, Point, jsonUtils, esriBundle) {    var clazz = declare(null, {        declaredClass: "esri.toolbars._GraphicVertexEditorEx",        graphic:null,        map:null,        toolbar:null,        symbol1:null,        symbol2:null,        vertexMoversGraphic:null,        mpVertexMovers:null,        ctxMenu:null,        ctxDelete:null,        selectedMoverGraphic:null,                constructor: function (graphic, map, toolbar) {            this.graphic = graphic;            this.map = map;            this.toolbar = toolbar;            var toolbarOpts = toolbar._options;            this.symbol1 = toolbarOpts.vertexSymbol;            this.symbol2 = toolbarOpts.ghostVertexSymbol;            var lienSymbol = toolbarOpts.ghostLineSymbol;            this.lineStroke = {style: lienSymbol.style, width: lienSymbol.width, color: lienSymbol.color};            this.canDel = toolbarOpts.allowDeleteVertices;            this.canAdd = toolbarOpts.allowAddVertices;            this.addControllers();        },        destroy: function () {            this.removeControllers()        },         refresh: function (isRefresh) {            if(isRefresh){                this.removeControllers();                this.addControllers();            }else{                this._refresh(this.vertexMoversGraphic);                this._refresh(this.mpVertexMovers);            }        },         suspend: function () {            this.suspended || this.removeControllers();            this.suspended = true        },         resume: function () {            this.suspended && this.addControllers();            this.suspended = false        },        addControllers: function () {            this.firstMoveConnect = connect.connect(VertexMoverEx, "onFirstMove", this, this.firstMoveHandler);            this.moveStopConnect = connect.connect(VertexMoverEx, "onMoveStop", this, this.moveStopHandler);            this.vertexMoversGraphic = this.add(this.getSegments(this.graphic.geometry), this.symbol1);            this.canAdd && (this.mpVertexMovers = this.add(this.getMidpointSegments(this.graphic.geometry), this.symbol2, true));            var graphicLayer = this.getGraphicsLayer();            this.mouseOverConnect = connect.connect(graphicLayer, "onMouseOver", this, this.mouseOverHandler);            this.mouseOutConnect = connect.connect(graphicLayer, "onMouseOut", this, this.mouseOutHandler);            this.canDel && (this.ctxMenu = new Menu({style: "font-size: 12px; margin-left: 5px; margin-top: 5px;"}),                graphicLayer = this.ctxDelete = new MenuItem({                    label: esriBundle.toolbars.edit.deleteLabel,                    iconClass: "vertexDeleteIcon",                    style: "outline: none;"                }),                 this.deleteConnect = connect.connect(graphicLayer, "onClick", this, this.deleteHandler),                 this.ctxMenu.addChild(graphicLayer), this.ctxMenu.startup())        },         removeControllers: function () {            connect.disconnect(this.firstMoveConnect);            connect.disconnect(this.moveStopConnect);            connect.disconnect(this.mouseOverConnect);            connect.disconnect(this.mouseOutConnect);            connect.disconnect(this.deleteConnect);            this.ctxMenu && (this.ctxDelete = null, this.unbindCtxNode(), this.ctxMenu.destroyRecursive());            this.remove(this.vertexMoversGraphic);            this.remove(this.mpVertexMovers);            this.vertexMoversGraphic = this.mpVertexMovers = null        },        add: function (segments, geoSymbol, option) {            var graphic = this.graphic, graphics = [];            for (var i = 0; i < segments.length; i++) {                var segment = segments[i];                vertexMovers = [];                for (var j = 0; j < segment.length; j++) {                    vertexMovers.push(new VertexMoverEx(segment[j], geoSymbol, graphic, i, j, segment.length, this, option))                }                graphics.push(vertexMovers)            }            return graphics        },         remove: function (graphics) {            graphics && array.forEach(graphics, function (graphic) {                array.forEach(graphic, function (P) {                    P.destroy()                })            })        },         _refresh: function (paths) {            paths && array.forEach(paths, function (path) {                array.forEach(path, function (graphic) {                    graphic.refresh()                })            })        },         isNew: function (graphicsegment) {            return -1 === array.indexOf(this.vertexMoversGraphic[graphicsegment.segIndex], graphicsegment) ? true : false        },        getGraphicsLayer: function () {            return this.toolbar.scratchGL        },        deleteHandler: function (selectedMover) {            selectedMover = this.selectedMoverGraphic;            this.updateRelatedGraphic(selectedMover, selectedMover.relatedGraphic, selectedMover.graphic.geometry, selectedMover.segIndex,                selectedMover.ptIndex, selectedMover.segLength, false, true);            this.canAdd && this.deleteMidpoints(selectedMover);            selectedMover.relatedGraphic.getDojoShape().moveToBack();            this.deleteVertex(selectedMover);            this.toolbar.endOperation("VERTICES")        },         mouseOverHandler: function (selectedMover) {            selectedMover = selectedMover.graphic;            var findMover = this.findMover(selectedMover);            findMover && (this.toolbar.onVertexMouseOver(this.graphic, findMover._getInfo()),             findMover.placeholder || (this.selectedMoverGraphic = findMover, this.canDel && this.bindCtxNode(selectedMover.getDojoShape().getNode())))        },        mouseOutHandler: function (mouseMover) {            if (mouseMover = this.findMover(mouseMover.graphic)) {                this.toolbar.onVertexMouseOut(this.graphic, mouseMover._getInfo())            }        },         bindCtxNode: function (bindNode) {            this.unbindCtxNode();            this.ctxDelete.set("disabled", this.selectedMoverGraphic.segLength <= this.minLength ? !0 : !1);            this.ctxMenu.bindDomNode(bindNode);            this._bindNode = bindNode        },         unbindCtxNode: function () {            var bindNode = this._bindNode;            bindNode && this.ctxMenu.unBindDomNode(bindNode)        },        findMover: function (graphic) {            var vertMovers, graphics = [];            vertMovers = this.mpVertexMovers;            array.forEach(this.vertexMoversGraphic, function (moversGraphic) {                graphics = graphics.concat(moversGraphic)            });            vertMovers && array.forEach(vertMovers, function (moversGraphic) {                graphics = graphics.concat(moversGraphic)            });            for (var i = 0; i < graphics.length; i++) {                var vertMove = graphics[i];                if (vertMove.graphic === graphic) {                    return vertMove                }            }        },        firstMoveHandler: function (vertMover) {            !this.isNew(vertMover) && this.canAdd && this.hideRelatedMidpoints(vertMover);            this.toolbar.beginOperation("VERTICES")        },         moveStopHandler: function (vertMover, option) {            var newVertMover = this.isNew(vertMover);            !option || !option.dx &&             !option.dy ?                 !newVertMover && this.canAdd && this.showRelatedMidpoints(vertMover) :                 (this.updateRelatedGraphic(vertMover, vertMover.relatedGraphic, vertMover.graphic.geometry, vertMover.segIndex,                    vertMover.ptIndex, vertMover.segLength, newVertMover),                this.canAdd && (newVertMover ? this.addMidpoints(vertMover) : (this.repositionRelatedMidpoints(vertMover), this.showRelatedMidpoints(vertMover))),                     this.toolbar.endOperation("VERTICES"))        },        showRelatedMidpoints: function (points) {            var midPoints = this.getAdjacentMidpoints(points.ptIndex, points.segLength);            var vertexMovers = this.mpVertexMovers[points.segIndex];            for (var i = 0; i < midPoints.length; i++) {                var vertexMover = vertexMovers[midPoints[i]];                vertexMover.graphic.show();                vertexMover.refresh()            }        },        hideRelatedMidpoints: function (points) {            var midPoints = this.getAdjacentMidpoints(points.ptIndex, points.segLength);            var vertexMovers = this.mpVertexMovers[points.segIndex];            for (var i = 0; i < midPoints.length; i++) {                vertexMovers[midPoints[i]].graphic.hide()            }        },         repositionRelatedMidpoints: function (points) {            var midPoints = this.getAdjacentMidpoints(points.ptIndex, points.segLength);            var vertexMovers = this.mpVertexMovers[points.segIndex];            for (var i = 0; i < midPoints.length; i++) {                var vertexs = this.getAdjacentVertices(midPoints[i], points.segLength),                    vertexs1 = points.relatedGraphic.geometry.getPoint(points.segIndex, vertexs[0]),                    vertexs = points.relatedGraphic.geometry.getPoint(points.segIndex, vertexs[1]),                    vertexs1 = new Point({x: (vertexs1.x + vertexs.x) / 2, y: (vertexs1.y + vertexs.y) / 2, spatialReference: vertexs1.spatialReference.toJson()});                vertexMovers[midPoints[i]].graphic.setGeometry(vertexs1)            }        },         addMidpoints: function (vertexsMovers) {            var segIndex = vertexsMovers.segIndex;            var ptIndex = vertexsMovers.ptIndex;            var segLength = vertexsMovers.segLength;            var ptIndex1 = ptIndex + 1;            var segLength1 = segLength + 1;            this.mpVertexMovers[segIndex].splice(ptIndex, 1);            var vertexs = this.vertexMoversGraphic[segIndex];            for (var i = 0; i < ptIndex1; i++) {                vertexs[i].segLength += 1            }            for (var i = ptIndex1; i < vertexs.length; i++) {                vertexs[i].ptIndex += 1, vertexs[i].segLength += 1            }            vertexsMovers.ptIndex = ptIndex1;            vertexsMovers.segLength = vertexs.length + 1;            vertexs.splice(ptIndex1, 0, vertexsMovers);            vertexsMovers.graphic.setSymbol(this.symbol1);            vertexs = this.mpVertexMovers[segIndex];            for (var i = 0; i < ptIndex; i++) {                vertexs[i].segLength += 1            }            for (var i = ptIndex; i < segLength - 1; i++) {                vertexs[i].ptIndex += 1, vertexs[i].segLength += 1            }            ptIndex1 = this.getAdjacentVertices(ptIndex, segLength1);            segIndex = this.getAdjacentVertices(ptIndex + 1, segLength1);            segLength = vertexsMovers.relatedGraphic.geometry.getPoint(vertexsMovers.segIndex, ptIndex1[0]);            var vertexsMoverPnts = vertexsMovers.relatedGraphic.geometry.getPoint(vertexsMovers.segIndex, ptIndex1[1]);            ptIndex1 = new Point({                x: (segLength.x + vertexsMoverPnts.x) / 2,                 y: (segLength.y + vertexsMoverPnts.y) / 2,                 spatialReference: segLength.spatialReference.toJson()});            segLength = vertexsMovers.relatedGraphic.geometry.getPoint(vertexsMovers.segIndex, segIndex[0]);            vertexsMoverPnts = vertexsMovers.relatedGraphic.geometry.getPoint(vertexsMovers.segIndex, segIndex[1]);            segIndex = new Point({                x: (segLength.x + vertexsMoverPnts.x) / 2,                 y: (segLength.y + vertexsMoverPnts.y) / 2,                 spatialReference: segLength.spatialReference.toJson()});            segLength = new VertexMoverEx(ptIndex1, this.symbol2, this.graphic, vertexsMovers.segIndex, ptIndex, segLength1, this, true);            vertexsMovers = new VertexMoverEx(segIndex, this.symbol2, this.graphic, vertexsMovers.segIndex, ptIndex + 1, segLength1, this, true);            vertexs.splice(ptIndex, 0, segLength, vertexsMovers)        },         deleteVertex: function (vertexMovers) {            var ptIndex = vertexMovers.ptIndex;            var vertexs = this.vertexMoversGraphic[vertexMovers.segIndex];            for (var i = 0; i < ptIndex; i++) {                vertexs[i].segLength -= 1            }            for (var i = ptIndex + 1; i < vertexs.length; i++) {                var vertex = vertexs[i];                vertex.ptIndex -= 1;                vertex.segLength -= 1            }            vertexs.splice(ptIndex, 1);            var vertexMoverInfo = vertexMovers._getInfo();            vertexMovers.destroy();            this.toolbar.onVertexDelete(this.graphic, vertexMoverInfo)        }    });    lang.mixin(clazz, {        create: function (vertexMover, option1, option2) {            switch (vertexMover.geometry.type) {                case"multipoint":                    return new clazz.MultipointVertexEditor(vertexMover, option1, option2);                case"polyline":                    return new clazz.PolylineVertexEditor(vertexMover, option1, option2);                case"polygon":                    return new clazz.PolygonVertexEditor(vertexMover, option1, option2)            }        }    });    clazz.MultipointVertexEditor = declare(clazz, {        declaredClass: "esri.toolbars._MultipointVertexEditor",        minLength: 1,        constructor: function () {            this.moveStartConnect = connect.connect(VertexMoverEx, "onMoveStart", this, this.moveStartHandler);            connect.disconnect(this.firstMoveConnect)        },        destroy: function () {            this.inherited(arguments);            connect.disconnect(this.moveStartConnect)        },        getSegments: function (segments) {            var segmentPoints = segments.points, segmentsPnts = [], segSpatialRef = segments.spatialReference;            for (var i = 0; i < segmentPoints.length; i++) {                var segmentPoint = segmentPoints[i];                segmentsPnts.push(new Point({x: segmentPoint[0], y: segmentPoint[1], spatialReference: segSpatialRef.toJson()}))            }            return [segmentsPnts]        },        getMidpointSegments: function (options) {            return []        },        getControlPoints: function (option1, option2, option3, option4, option5) {            return []        },        getGraphicsLayer: function () {            return this.graphic._graphicsLayer        },        mouseOverHandler: function (evt) {            var graphic = evt.graphic;            if (evt = this.findMover(evt)) {                this.toolbar.onVertexMouseOver(graphic, evt._getInfo());                this.selectedMoverGraphic = evt;                this.canDel && this.bindCtxNode(evt.graphic.getDojoShape().getNode());            }        },        mouseOutHandler: function (evt) {            var graphic = evt.graphic;            if (evt = this.findMover(evt)) {                this.toolbar.onVertexMouseOut(graphic, evt._getInfo())            }        },        findMover: function (evt) {            var vertexMovers = [].concat(this.vertexMoversGraphic[0]), P = evt.target;            for (var i = 0; i < vertexMovers.length; i++) {                var vertexMover = vertexMovers[i];                if (vertexMover.graphic.getDojoShape().getNode() === P) {                    return vertexMover                }            }        },        moveStartHandler: function (evt) {            var ptIndex = evt.ptIndex, segLength = evt.segLength - 1, points = evt.relatedGraphic.geometry.points;            evt = points.splice(ptIndex, 1);            points.push(evt[0]);            points = this.vertexMoversGraphic[0];            for (evt = segLength; evt > ptIndex; evt--) {                points[evt].ptIndex -= 1            }            evt = points.splice(ptIndex, 1);            points.push(evt[0]);            evt[0].ptIndex = segLength        },        moveStopHandler: function (evt) {            this.updateRelatedGraphic(evt, evt.relatedGraphic, evt.graphic.geometry, evt.segIndex, evt.ptIndex, evt.segLength);            this.toolbar.endOperation("VERTICES")        },        updateRelatedGraphic: function (grphic, grphic1, pntY, option1, pntX, option2, option3, option4) {            grphic = grphic1.geometry;            option4 ? grphic.removePoint(pntX) : grphic.setPoint(pntX, pntY);            grphic1.setGeometry(grphic)        },        deleteMidpoints: function (evt) {        }    });    clazz.PolylineVertexEditor = declare(clazz, {        declaredClass: "esri.toolbars._PolylineVertexEditor",        minLength: 2,        getSegments: function (segments) {            var segPaths = segments.paths, getSegs = [];            for (var i = 0; i < segPaths.length; i++) {                var P = segPaths[i], segment = [];                for (var j = 0; j < P.length; j++) {                    segment.push(segments.getPoint(i, j))                }                getSegs.push(segment)            }            return getSegs        },        getMidpointSegments: function (segments) {            var paths = segments.paths, pntSegments = [], segSpatialRef = segments.spatialReference;            for (var i = 0; i < paths.length; i++) {                var pathPnts = paths[i], pathPnt = [];                for (var j = 0; j < pathPnts.length - 1; j++) {                    var segPnts = segments.getPoint(i, j), Q = segments.getPoint(i, j + 1),                        segPnts = new Point({x: (segPnts.x + Q.x) / 2, y: (segPnts.y + Q.y) / 2, spatialReference: segSpatialRef.toJson()});                    pathPnt.push(segPnts)                }                pntSegments.push(pathPnt)            }            return pntSegments        },        getControlPoints: function (pnts, pnts1, pnts2, pnts3, pnts4) {            var map = this.map, mapPnt1, mapPnt2;            this.isNew(pnts) ?                (pnts = pnts3, pnts3 += 1, 0 <= pnts && (mapPnt1 = map.toScreen(pnts1.getPoint(pnts2, pnts))),                pnts3 <= pnts4 && (mapPnt2 = map.toScreen(pnts1.getPoint(pnts2, pnts3)))) :                (pnts = pnts3 - 1, pnts3 += 1, 0 <= pnts && (mapPnt1 = map.toScreen(pnts1.getPoint(pnts2, pnts))),                pnts3 < pnts4 && (mapPnt2 = map.toScreen(pnts1.getPoint(pnts2, pnts3))));            return [mapPnt1, mapPnt2]        },        getAdjacentMidpoints: function (mapPnt1, mapPnt2) {            var mapPnts = [], mapPnt3 = mapPnt1 - 1;            0 <= mapPnt3 && mapPnts.push(mapPnt3);            mapPnt1 < mapPnt2 - 1 && mapPnts.push(mapPnt1);            return mapPnts        },        getAdjacentVertices: function (vertice, option) {            return [vertice, vertice + 1]        },        deleteMidpoints: function (points) {            var vertexMovers = this.mpVertexMovers[points.segIndex];            var vertexMoversLen = vertexMovers.length - 1;            var midPoints = this.getAdjacentMidpoints(points.ptIndex, points.segLength).sort();            var midPoints0 = midPoints[0];            for (var i = 0; i < midPoints0; i++) {                vertexMovers[i].segLength -= 1            }            for (var i = midPoints0 + 1; i < vertexMovers.length; i++) {                var vertexMover = vertexMovers[i];                vertexMover.ptIndex -= 1;                vertexMover.segLength -= 1            }            if (1 === midPoints.length) {                vertexMovers.splice(midPoints0, 1)[0].destroy()            } else {                vertexMover = this.getAdjacentVertices(midPoints0, vertexMoversLen);                var relatedPoints = points.relatedGraphic.geometry.getPoint(points.segIndex, vertexMover[0]);                vertexMover = points.relatedGraphic.geometry.getPoint(points.segIndex, vertexMover[1]);                relatedPoints = new Point({                    x: (relatedPoints.x + vertexMover.x) / 2,                    y: (relatedPoints.y + vertexMover.y) / 2,                    spatialReference: relatedPoints.spatialReference.toJson()});                points = new VertexMoverEx(relatedPoints, this.symbol2, this.graphic, points.segIndex, midPoints0, vertexMoversLen, this, true);                vertexMovers = vertexMovers.splice(midPoints0, midPoints.length, points);                for (relatedPoints = 0; relatedPoints < vertexMovers.length; relatedPoints++) {                    vertexMovers[relatedPoints].destroy()                }            }        },        updateRelatedGraphic: function (geometry, graphic, pnt1, pnt2, pnt3, pnt4, pnt5, pnt6) {            geometry = graphic.geometry;            pnt5 ?                geometry.insertPoint(pnt2, pnt3 + 1, jsonUtils.fromJson(pnt1.toJson())) :                pnt6 ? geometry.removePoint(pnt2, pnt3) : geometry.setPoint(pnt2, pnt3, jsonUtils.fromJson(pnt1.toJson()));            graphic.setGeometry(geometry)        }    });    clazz.PolygonVertexEditor = declare(clazz, {        declaredClass: "esri.toolbars._PolygonVertexEditor",        minLength: 3,        getSegments: function (polygon) {            var rings = polygon.rings, segments = [];            for (var i = 0; i < rings.length; i++) {                var ring = rings[i], segment = [];                for (var j = 0; j < ring.length - 1; j++) {                    segment.push(polygon.getPoint(i, j))                }                segments.push(segment)            }            return segments        },        getMidpointSegments: function (polygon) {            var rings = polygon.rings, segments = [], pSpatialRef = polygon.spatialReference;            for (var i = 0; i < rings.length; i++) {                var ring = rings[i], segRings = [];                for (var j = 0; j < ring.length - 1; j++) {                    var segPoint = polygon.getPoint(i, j), Q = polygon.getPoint(i, j + 1),                        segPoint = new Point({x: (segPoint.x + Q.x) / 2, y: (segPoint.y + Q.y) / 2, spatialReference: pSpatialRef.toJson()});                    segRings.push(segPoint)                }                segments.push(segRings)            }            return segments        },        getControlPoints: function (pnt1, pnt2, pnt3, pnt4, pnt5) {            var map = this.map;            this.isNew(pnt1) ? pnt1 = pnt4 : (pnt1 = pnt4 - 1, pnt1 = 0 > pnt1 ? (pnt5 + pnt1) % pnt5 : pnt1);            pnt4 = (pnt4 + 1) % pnt5;            pnt5 = map.toScreen(pnt2.getPoint(pnt3, pnt1));            pnt2 = map.toScreen(pnt2.getPoint(pnt3, pnt4));            return [pnt5, pnt2]        },        getAdjacentMidpoints: function (pnt1, pnt2) {            var pnt3 = pnt1 - 1;            return [0 > pnt3 ? (pnt2 + pnt3) % pnt2 : pnt3, pnt1]        },        getAdjacentVertices: function (pnt1, pnt2) {            return [pnt1, (pnt1 + 1) % pnt2]        },        deleteMidpoints: function (pnt) {            var ptIndex = pnt.ptIndex;            var vertexMover = this.mpVertexMovers[pnt.segIndex];            var vertexMoverLen = vertexMover.length - 1;            var midPnts = this.getAdjacentMidpoints(ptIndex, pnt.segLength).sort();            var adjVertices;            var midPnts0 = midPnts[0];            var midPntLast = midPnts[midPnts.length - 1];            if (0 === ptIndex) {                adjVertices = this.getAdjacentVertices(vertexMoverLen - 1, vertexMoverLen);                ptIndex = pnt.relatedGraphic.geometry.getPoint(pnt.segIndex, adjVertices[0]);                adjVertices = pnt.relatedGraphic.geometry.getPoint(pnt.segIndex, adjVertices[1]);                ptIndex = new Point({                    x: (ptIndex.x + adjVertices.x) / 2,                    y: (ptIndex.y + adjVertices.y) / 2,                    spatialReference: ptIndex.spatialReference.toJson()});                pnt = new VertexMoverEx(ptIndex, this.symbol2, this.graphic, pnt.segIndex, vertexMoverLen - 1, vertexMoverLen, this, true);                vertexMover.splice(midPntLast, 1, pnt)[0].destroy();                vertexMover.splice(midPnts0, 1)[0].destroy();                for (var i = 0; i < vertexMover.length - 1; i++) {                    midPnts0 = vertexMover[i], midPnts0.ptIndex -= 1, midPnts0.segLength -= 1                }            } else {                adjVertices = this.getAdjacentVertices(midPnts0, vertexMoverLen);                ptIndex = pnt.relatedGraphic.geometry.getPoint(pnt.segIndex, adjVertices[0]);                adjVertices = pnt.relatedGraphic.geometry.getPoint(pnt.segIndex, adjVertices[1]);                ptIndex = new Point({                    x: (ptIndex.x + adjVertices.x) / 2,                    y: (ptIndex.y + adjVertices.y) / 2,                    spatialReference: ptIndex.spatialReference.toJson()});                pnt = new VertexMoverEx(ptIndex, this.symbol2, this.graphic, pnt.segIndex, midPnts0, vertexMoverLen, this, true);                midPntLast = vertexMover.splice(midPnts0, midPnts.length, pnt);                for (var i = 0; i < midPntLast.length; i++) {                    midPntLast[i].destroy()                }                for (var i = 0; i < midPnts0; i++) {                    vertexMover[i].segLength -= 1                }                for (var i = midPnts0 + 1; i < vertexMover.length; i++) {                    midPnts0 = vertexMover[i], midPnts0.ptIndex -= 1, midPnts0.segLength -= 1                }            }        },        updateRelatedGraphic: function (geometry, graphic, pnt1, pnt2, pnt3, pnt4, pnt5, pnt6) {            geometry = graphic.geometry;            pnt5 ? geometry.insertPoint(pnt2, pnt3 + 1, jsonUtils.fromJson(pnt1.toJson())) :                pnt6 ? (geometry.removePoint(pnt2, pnt3), 0 === pnt3 && geometry.setPoint(pnt2, pnt4 - 1, jsonUtils.fromJson(geometry.getPoint(pnt2, 0).toJson()))) :                    (geometry.setPoint(pnt2, pnt3, jsonUtils.fromJson(pnt1.toJson())), 0 === pnt3 && geometry.setPoint(pnt2, pnt4, jsonUtils.fromJson(pnt1.toJson())));            graphic.setGeometry(geometry)        }    });    has("extend-esri") &&    (lang.setObject("toolbars._GraphicVertexEditorEx", clazz, kernel),        lang.setObject("toolbars._MultipointVertexEditor", clazz.MultipointVertexEditor, kernel),        lang.setObject("toolbars._PolylineVertexEditor", clazz.PolylineVertexEditor, kernel),        lang.setObject("toolbars._PolygonVertexEditor", clazz.PolygonVertexEditor, kernel));    return clazz});