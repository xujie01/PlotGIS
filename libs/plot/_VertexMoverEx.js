define(["dojo/_base/declare","dojo/_base/lang","dojo/_base/connect","dojo/has","dojo/sniff","dojo/dom-style",    "dojox/gfx/Moveable","esri/kernel","esri/geometry/Point","esri/graphic","esri/geometry/webMercatorUtils"],     function (declare, lang, connect, has, sniff, domStyle, Moveable, kernel, Point, Graphic, webMercatorUtils) {    var clazz = declare(null, {        declaredClass: "esri.toolbars.VertexMoverEx",        point:null,        symbol:null,        relatedGraphic:null,        segIndex:null,        ptIndex:null,        segLength:null,        editor:null,        map:null,        scratchGL:null,        geometryType:null,        moveable:null,                constructor: function (point, symbol, relatedGraphic, segIndex, ptIndex, segLength, editor, placeholder) {            this.point = point;            this.symbol = symbol;            this.relatedGraphic = relatedGraphic;            this.segIndex = segIndex;            this.ptIndex = ptIndex;            this.segLength = segLength;            this.editor = editor;            this.map = editor.map;            this.scratchGL = editor.toolbar.scratchGL;            this.placeholder = placeholder || false;            this.geometryType = relatedGraphic.geometry.type;            this.init();            this.enable();        },        init: function () {            var mapPnt = new Point(this.point.toJson());            var mapGraphic = new Graphic(mapPnt, this.symbol);            switch (this.geometryType) {                case"multipoint":                    mapGraphic._shape = this.relatedGraphic.getDojoShape().children[this.ptIndex];                    break;                case"polyline":                case"polygon":                    this.scratchGL.add(mapGraphic)            }            this.graphic = mapGraphic        },        enable: function () {            var dojoShape = this.graphic.getDojoShape();            dojoShape && (dojoShape._hasMover = true, this.moveable = this.getMoveable(dojoShape),             (dojoShape = dojoShape.getEventSource()) && domStyle.set(dojoShape, "cursor", this.editor.toolbar._cursors[this.placeholder ? "move-gv" : "move-v"]))        },        refresh: function (isRefresh) {            if (isRefresh || this.needRefresh()) {                this.disable();                this.enable();            }        },         destroy: function () {            this.disable();            this.graphic && this.scratchGL.remove(this.graphic);            this.point = this.symbol = this.graphic = this.relatedGraphic = this.segIndex = this.ptIndex = this.segLength = this.editor = this.map = this.scratchGL = null        },        disable: function () {            var moveable = this.moveable;            if (moveable) {                connect.disconnect(this.startConnect);                connect.disconnect(this.firstConnect);                connect.disconnect(this.movingConnect);                connect.disconnect(this.stopConnect);                var moveshape = moveable.shape;                moveshape && (moveshape = moveshape.getEventSource()) && domStyle.set(moveshape, "cursor", null);                moveable.destroy();                this.moveable = null            }        },         needRefresh: function () {            var dojoShape = this.graphic.getDojoShape(), isRefresh = false;            if (dojoShape) {                switch (this.geometryType) {                    case"multipoint":                        var relShape = this.relatedGraphic.getDojoShape();                        relShape && (relShape = relShape.children[this.ptIndex], dojoShape !== relShape && (this.graphic._shape = relShape, isRefresh = true));                        break;                    case"polyline":                    case"polygon":                        isRefresh = !dojoShape._hasMover                }            }            return isRefresh        },         getMoveable: function (moveAble) {            moveAble = new Moveable(moveAble, sniff("mac") && sniff("ff") && !has("esri-touch") && {leftButtonOnly: true});            this.startConnect = connect.connect(moveAble, "onMoveStart", this, this.moveStartHandler);            this.firstConnect = connect.connect(moveAble, "onFirstMove", this, this.firstMoveHandler);            this.movingConnect = connect.connect(moveAble, "onMoving", this, this.movingHandler);            this.stopConnect = connect.connect(moveAble, "onMoveStop", this, this.moveStopHandler);            return moveAble        },         getPntIndex: function () {            return this.ptIndex + (this.placeholder ? 1 : 0)        },        _getInfo: function () {            return {                graphic: this.graphic,                isGhost: this.placeholder,                segmentIndex: this.segIndex,                pointIndex: this.getPntIndex()            }        },        moveStartHandler: function (evt) {            var map = this.map;            map.snappingManager && map.snappingManager._setUpSnapping();            evt.shape.moveToFront();            this.constructor.onMoveStart(this);            this.editor.toolbar.onVertexMoveStart(this.relatedGraphic, this._getInfo())        },         firstMoveHandler: function (evt) {            var shape = evt.shape;            var controlEdges = this.getControlEdges();            var glDiv = this.scratchGL._div;            var controlEdgesLen, controlPnts = [], wrapOffset = evt.host.shape._wrapOffsets[0] || 0;            for (controlEdgesLen = 0; controlEdgesLen < controlEdges.length; controlEdgesLen++) {                var controlEdge = controlEdges[controlEdgesLen];                controlEdge.x1 += wrapOffset;                controlEdge.x2 += wrapOffset;                controlPnts.push([glDiv.createLine({                    x1: controlEdge.x1,                    y1: controlEdge.y1,                    x2: controlEdge.x2,                    y2: controlEdge.y2                }).setStroke(this.editor.lineStroke), controlEdge.x1, controlEdge.y1, controlEdge.x2, controlEdge.y2])            }            shape._lines = controlPnts;            evt.shape.moveToFront();            this.constructor.onFirstMove(this);            this.editor.toolbar.onVertexFirstMove(this.relatedGraphic, this._getInfo())        },         movingHandler: function (evt) {            var shape = evt.shape.getTransform();            var shapeLines = evt.shape._lines;            for (var i = 0; i < shapeLines.length; i++) {                var shapeLine = shapeLines[i];                shapeLine[0].setShape({x1: shapeLine[1] + shape.dx, y1: shapeLine[2] + shape.dy, x2: shapeLine[3], y2: shapeLine[4]})            }            this.editor.toolbar.onVertexMove(this.relatedGraphic, this._getInfo(), shape)        },         moveStopHandler: function (evt) {            var shape = evt.shape;            var toolbar = this.editor.toolbar;            var shapeT = shape.getTransform();            var map = this.map;            var graphic = this.graphic;            var toolbarGeo = toolbar._geo ? webMercatorUtils.geographicToWebMercator(graphic.geometry) : graphic.geometry;            var shapeLines = shape._lines;            if (shapeLines) {                for (var i = 0; i < shapeLines.length; i++) {                    shapeLines[i][0].removeShape()                }                shape._lines = null            }            var mEnble = false, vEnble = true, shapeInfo = this._getInfo();            shapeT && (shapeT.dx || shapeT.dy) ? this.placeholder && (this.placeholder = false, mEnble = true) : vEnble = false;            var snappingPoint;            map.snappingManager && (snappingPoint = map.snappingManager._snappingPoint);            snappingPoint = snappingPoint || map.toMap(map.toScreen(toolbarGeo).offset(shapeT.dx, shapeT.dy));            map.snappingManager && map.snappingManager._killOffSnapping();            shape.setTransform(null);            graphic.setGeometry(toolbar._geo ? webMercatorUtils.webMercatorToGeographic(snappingPoint, true) : snappingPoint);            this.constructor.onMoveStop(this, shapeT);            toolbar.onVertexMoveStop(this.relatedGraphic, shapeInfo, shapeT);            if (!vEnble) {                toolbar.onVertexClick(this.relatedGraphic, shapeInfo)            }            if (mEnble) {                toolbar.onVertexAdd(this.relatedGraphic, this._getInfo())            }            this.relatedGraphic.getDojoShape().moveToBack()        },        getControlEdges: function () {            var map = this.map;            var rGeometry = this.relatedGraphic.geometry;            var segIndex = this.segIndex;            var ptIndex = this.ptIndex;            var segLength = this.segLength;            var glDiv = this.scratchGL._div.getTransform();            var glDivDx = glDiv.dx;            var glDivDy = glDiv.dy;            var mapPnt = map.toScreen(this.graphic.geometry);            var mapPntX = mapPnt.x - glDivDx;            var mapPntY = mapPnt.y - glDivDy;            var edges = [], rGeometry = this.editor.getControlPoints(this, rGeometry, segIndex, ptIndex, segLength);            rGeometry[0] && edges.push({x1: mapPntX, y1: mapPntY, x2: rGeometry[0].x - glDivDx, y2: rGeometry[0].y - glDivDy});            rGeometry[1] && edges.push({x1: mapPntX, y1: mapPntY, x2: rGeometry[1].x - glDivDx, y2: rGeometry[1].y - glDivDy});            return edges        }    });    has("extend-esri") && lang.setObject("toolbars.VertexMover", clazz, kernel);    lang.mixin(clazz, {        onMoveStart: function () {},         onFirstMove: function () {},         onMoveStop: function () {}    });    return clazz});