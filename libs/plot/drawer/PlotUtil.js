define(["dojo/_base/lang", "esri/geometry/Point"],    function (lang, Point) {    var clazz = {};    clazz.LEFT_SIDE = "left";    clazz.RIGHT_SIDE = "right";    clazz.USE_BEZIER_FIT = "useBezierFit";    clazz.USE_BSPLINE_FIT = "useBSplieFit";    clazz.distance = function (pnt1, pnt2) {        return Math.sqrt(Math.pow(pnt1.x - pnt2.x, 2) + Math.pow(pnt1.y - pnt2.y, 2))    };    clazz.getMidPoint = function (pnt1, pnt2) {        return new Point((pnt1.x + pnt2.x) / 2, (pnt1.y + pnt2.y) / 2)    };    clazz.getThirdPoint = function (pnoffsetX, pnoffsetY, N1, N2, type) {        var tAngle = null;        var angle = this.getAzimuthAngle(pnoffsetX, pnoffsetY);        if (type == this.LEFT_SIDE) {            tAngle = angle + N1        } else {            tAngle = angle - N1        }        var offsetX = N2 * Math.cos(tAngle);        var offsetY = N2 * Math.sin(tAngle);        return new Point(pnoffsetY.x + offsetX, pnoffsetY.y + offsetY)    };    clazz.getAzimuthAngle = function (pnt1, pnt2) {        var angle = NaN;        var disY = Math.asin(Math.abs(pnt2.y - pnt1.y) / this.distance(pnt1, pnt2));        if (pnt2.y >= pnt1.y && pnt2.x >= pnt1.x) {            angle = disY + Math.PI        } else {            if (pnt2.y >= pnt1.y && pnt2.x < pnt1.x) {                angle = 2 * Math.PI - disY            } else {                if (pnt2.y < pnt1.y && pnt2.x < pnt1.x) {                    angle = disY                } else {                    if (pnt2.y < pnt1.y && pnt2.x >= pnt1.x) {                        angle = Math.PI - disY                    }                }            }        }        return angle    };    clazz.getBezierPoints = function (points) {        var pointsX , pointsY, biomial, Q1, Q2;        if (points.length <= 2) {            return points        }        var pnts = [];        var pntsLen = points.length - 1;        var Q3 = 0;        while (Q3 <= 1) {            pointsX = 0;            pointsY = 0;            var j = 0;            while (j <= pntsLen) {                biomial = this.getBinomialFactor(pntsLen, j);                Q1 = Math.pow(Q3, j);                Q2 = Math.pow(1 - Q3, pntsLen - j);                pointsX = pointsX + biomial * Q1 * Q2 * points[j].x;                pointsY = pointsY + biomial * Q1 * Q2 * points[j].y;                j++            }            pnts.push(new Point(pointsX, pointsY));            Q3 = Q3 + 0.01        }        pnts.push(points[pntsLen]);        return pnts    };    clazz.getBinomialFactor = function (pntsLen, n) {        return this.getFactorial(pntsLen) / (this.getFactorial(n) * this.getFactorial(pntsLen - n))    };    clazz.getFactorial = function (N) {        if (N <= 1) {            return 1        }        if (N == 2) {            return 2        }        if (N == 3) {            return 6        }        if (N == 4) {            return 24        }        if (N == 5) {            return 120        }        var factorial = 1;        var j = 1;        while (j <= N) {            factorial = factorial * j;            j++        }        return factorial    };    clazz.getAdvancedBezierPoints = function (points) {        var d1, d2, d3, d4, dX, dY;        var pnts = points.slice();        var pntsLen = pnts.length;        pnts.push(pnts[0]);        var tempPoints = [];        var j = 0;        while (j < pntsLen) {            tempPoints.push(this.getMidPoint(pnts[j], pnts[(j + 1)]));            j++        }        tempPoints.push(tempPoints[0]);        pnts.push(pnts[1]);        var thirdPoints = [];        j = 0;        while (j < pntsLen) {            d1 = this.distance(pnts[j], pnts[(j + 1)]);            d2 = this.distance(pnts[(j + 1)], pnts[j + 2]);            d3 = this.distance(tempPoints[j], tempPoints[(j + 1)]);            d4 = d3 * d1 / (d1 + d2);            thirdPoints.push(this.getThirdPoint(tempPoints[(j + 1)], tempPoints[j], 0, d4, this.LEFT_SIDE));            j++        }        var afterPoints = [];        j = 0;        while (j < pntsLen) {            dX = pnts[(j + 1)].x - thirdPoints[j].x;            dY = pnts[(j + 1)].y - thirdPoints[j].y;            afterPoints.push(new Point(tempPoints[j].x + dX, tempPoints[j].y + dY));            afterPoints.push(pnts[(j + 1)]);            afterPoints.push(new Point(tempPoints[(j + 1)].x + dX, tempPoints[(j + 1)].y + dY));            j++        }        var bezierPnts = [];        var afterClonePoints = afterPoints.slice();        afterPoints.slice().push(afterPoints[0], afterPoints[1]);        j = 1;        while (j < afterClonePoints.length) {            bezierPnts = bezierPnts.concat(this.getBezierPoints(afterClonePoints.slice(j, j + 4)));            j = j + 3        }        return bezierPnts    };    clazz.getAngleOfThreePoints = function (pnt1, pnt2, pnt3) {        var angle = this.getAzimuthAngle(pnt2, pnt1) - this.getAzimuthAngle(pnt2, pnt3);        if (this.getAzimuthAngle(pnt2, pnt1) - this.getAzimuthAngle(pnt2, pnt3) < 0) {            angle = angle + Math.PI * 2        }        return angle    };    clazz.getArrowHeadPoints = function (points, N1, N2, N3, N4) {        var pntsLen1 = this.getBaseLength(points) * N1;        var pntsLen2 = this.getBaseLength(points) * N1 * N2;        var pntsLen3 = pntsLen1 * N4;        var pntsLen = points.length;        var pntLast = points[(pntsLen - 1)];        var pntsDis = this.distance(pntLast, points[pntsLen - 2]);        pntsLen1 = pntsLen1 > pntsDis ? (pntsDis) : (pntsLen1);        var pntsLen4 = pntsLen1 * N3;        var thirdPnt1 = this.getThirdPoint(points[pntsLen - 2], pntLast, 0, pntsLen1, this.LEFT_SIDE);        var thirdPnt2 = this.getThirdPoint(points[pntsLen - 2], pntLast, 0, pntsLen4, this.LEFT_SIDE);        var thirdPnt3 = this.getThirdPoint(pntLast, thirdPnt1, Math.PI * 1.5, pntsLen2, this.RIGHT_SIDE);        var thirdPnt4 = this.getThirdPoint(pntLast, thirdPnt2, Math.PI * 1.5, pntsLen3, this.RIGHT_SIDE);        var thirdPnt5 = this.getThirdPoint(pntLast, thirdPnt1, Math.PI * 1.5, pntsLen2, this.LEFT_SIDE);        var thirdPnt6 = this.getThirdPoint(pntLast, thirdPnt2, Math.PI * 1.5, pntsLen3, this.LEFT_SIDE);        var arrowHeadPnts = [];        arrowHeadPnts.push(thirdPnt4, thirdPnt3, pntLast, thirdPnt5, thirdPnt6);        return arrowHeadPnts    };    clazz.getBaseLength = function (points) {        var pntsLen = this.wholeDistance(points);        return pntsLen    };    clazz.wholeDistance = function (points) {        if (points.length <= 1) {            return 0        }        var wDistance = 0;        var j = 0;        while (j < (points.length - 1)) {            wDistance = wDistance + this.distance(points[j], points[(j + 1)]);            j++        }        return wDistance    };    clazz.getArrowBodyPoints = function (pnts, pnt1, pnt2, N) {        var angle , N1;        var wDistance = this.wholeDistance(pnts);        var baseLen = this.getBaseLength(pnts) * N;        var disPnts = this.distance(pnt1, pnt2);        var N2 = baseLen - disPnts / 2;        var N3 = 0;        var points = [];        var thirdPnts = [];        var j = 1;        while (j < (pnts.length - 1)) {            angle = this.getAngleOfThreePoints(pnts[(j - 1)], pnts[j], pnts[(j + 1)]) / 2;            N3 = N3 + this.distance(pnts[(j - 1)], pnts[j]);            N1 = (baseLen - N3 / wDistance * N2) / Math.sin(angle);            points.push(this.getThirdPoint(pnts[(j - 1)], pnts[j], angle, N1 * 1, this.RIGHT_SIDE));            thirdPnts.push(this.getThirdPoint(pnts[(j - 1)], pnts[j], Math.PI - angle, N1 * 1, this.LEFT_SIDE));            j++        }        return points.concat(thirdPnts)    };    clazz.getArrowPlot = function (points, N1, N2, type, N3, N4, N5, N6, N7) {        var pnts = points.slice();        var aHeadPoints = this.getArrowHeadPoints(pnts, N3, N4, N5, N6);        var aHeadPoint1 = aHeadPoints[0];        var aHeadPoint2 = aHeadPoints[4];        var aHeadPoints1 = this.getArrowBodyPoints(pnts, aHeadPoint1, aHeadPoint2, N7);        var aTailPoints = this.getArrowTailPoints(pnts, N7, N1, N2);        var aTailPoint1 = aTailPoints[0];        var aTailPoint2 = aTailPoints.length == 3 ? (aTailPoints[1]) : (null);        var aTailPoint3 = aTailPoints.length == 3 ? (aTailPoints[2]) : (aTailPoints[1]);        var aHeadPntsLen1 = aHeadPoints1.length;        var aHeadPntsLen2 = aHeadPoints1.slice(0, aHeadPntsLen1 / 2);        var aHeadPntsLen3 = aHeadPoints1.slice(aHeadPntsLen1 / 2, aHeadPntsLen1);        aHeadPntsLen2.push(aHeadPoint1);        aHeadPntsLen3.push(aHeadPoint2);        aHeadPntsLen2 = aHeadPntsLen2.reverse();        aHeadPntsLen2.push(aTailPoint1);        aHeadPntsLen3 = aHeadPntsLen3.reverse();        aHeadPntsLen3.push(aTailPoint3);        if (type == this.USE_BEZIER_FIT) {            aHeadPntsLen2 = this.getBezierPoints(aHeadPntsLen2);            aHeadPntsLen3 = this.getBezierPoints(aHeadPntsLen3)        } else {            aHeadPntsLen2 = this.getBSplinePoints(aHeadPntsLen2);            aHeadPntsLen3 = this.getBSplinePoints(aHeadPntsLen3)        }        if (aTailPoint2) {            aHeadPntsLen2.push(aTailPoint2);            aHeadPntsLen3.push(aTailPoint2)        }        var arrowPlots = aHeadPntsLen2.reverse().concat(aHeadPoints, aHeadPntsLen3);        var arrowPlot = null;        for (var j = 0; j < arrowPlots.length; j++) {            if (arrowPlot == null) {                arrowPlot = arrowPlots[0];                continue            }            if (arrowPlot == arrowPlots[j]) {            } else {                arrowPlot = arrowPlots[j]            }        }        return arrowPlots    };    clazz.getBSplinePoints = function (points, N) {        N = 2;        var N1, N2, N3, j, bSplineF;        if (points.length <= 2 || points.length <= N) {            return points        }        var bPoints = [];        var pointsLast = points.length - N - 1;        bPoints.push(points[0]);        var m = 0;        while (m <= pointsLast) {            N1 = 0;            while (N1 <= 1) {                N2 = 0;                N3 = 0;                j = 0;                while (j <= N) {                    bSplineF = this.getBSplineFFactor(j, N, N1);                    N2 = N2 + bSplineF * points[m + j].x;                    N3 = N3 + bSplineF * points[m + j].y;                    j++                }                bPoints.push(new Point(N2, N3));                N1 = N1 + 0.05            }            m++        }        bPoints.push(points[(points.length - 1)]);        return bPoints    };    clazz.getBSplineFFactor = function (N1, N2, N3) {        var N4;        if (N2 == 2) {            return this.getQuadricBSplineFactor(N1, N3)        }        var m = 0;        var factorial = this.getFactorial(N2);        var j = 0;        while (j <= N2 - N1) {            N4 = j % 2 == 0 ? (1) : (-1);            m = m + N4 * this.getBinomialFactor((N2 + 1), j) * Math.pow(N3 + N2 - N1 - j, N2);            j++        }        return m / factorial    };    clazz.getQuadricBSplineFactor = function (N1, N2) {        if (N1 == 0) {            return Math.pow((N2 - 1), 2) / 2        }        if (N1 == 1) {            return (-2 * Math.pow(N2, 2) + 2 * N2 + 1) / 2        }        if (N1 == 2) {            return Math.pow(N2, 2) / 2        }        return 0    };    clazz.getArrowTailPoints = function (points, N1, N2, N3) {        var N4, N5;        var bLen = this.getBaseLength(points) * N1;        var aTailPoints = [];        var thirdPnt1 = this.getThirdPoint(points[1], points[0], Math.PI * 1.5, bLen, this.RIGHT_SIDE);        var thirdPnt2 = this.getThirdPoint(points[1], points[0], Math.PI * 1.5, bLen, this.LEFT_SIDE);        if (N2) {            N4 = bLen * N3;            N5 = this.getThirdPoint(points[1], points[0], 0, N4, this.LEFT_SIDE);            aTailPoints.push(thirdPnt1, N5, thirdPnt2);            return aTailPoints        }        aTailPoints.push(thirdPnt1, thirdPnt2);        return aTailPoints    };    return clazz});